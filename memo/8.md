# 8章memo

## エラー処理

- 関数が期待通りに実行された場合はerrorにはnilを返却する
  - nilを返却するのはインタフェース型の初期値のため
- 何かがうまく行かない場合は、エラーを返す値が返される
- 呼び出し側ではerrorの戻り値をnilと比較することでチェックし、そのエラーを処理したり、独自のエラーを返したりする
- エラーメッセージを英語で書く場合、先頭の大文字は不要で、ピリオドも使用しない
  - エラー文字列は他の出力で使用する可能性があるため
- 例外を使用するのではなく、エラーを返す理由は２種類ある
  - 例外があるとコードの道を少なくとも１本新たに加えることになるため
  - エラーチェック or エラー無視を開発者が選択できるため
- カスタマイズされたエラー型を使用する際は、変数をカスタマイズされたエラー型で定義してはいけない
  - nilでの判別ができないため
    - 基底型と値の両方がnilでなければnilと判定されない
- エラーをラップしたい場合は、`fmt.Errorf`で`%w`と指定し受け取ったエラーに挿入する
- エラーの場合分けを行いたい場合は、特定の値を探している場合は`errors.Is`、特定の型を探している場合は`errors.as`を用いて比較する

## センチメンタルエラー

- 現在の状態には問題があり処理を継続できない事を知らせる目的としたエラーのこと
  - 例：`archive/zip`では指定されたファイルがZIP形式ではない場合にErrFormatが発生する
- パッケージレベルで宣言される
- 慣習により名前はErrで始まる
- 読み込みのみで扱わなければならない
- チェックは`==`を使って比較し処理する

## パニックとリカバー

- Goのランタイムが次に何をすればいいのかがわからなくなった場合にパニックが発生する
- パニックが発生すると実行中の関数は即座に終了し、deferが実行される
- panicを補足したい場合は、recoverを使用する
- recoverで補足する場合は、ログを吐いて処理を終了するなど、処理を続行する事を考えてはいけない