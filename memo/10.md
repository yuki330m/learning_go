# 10章memo

## ゴルーチン

- プロセス
  - 具体的なプログラムがコンピューターのOSによって実行されているもの
  - OSは何らかのリソースをプロセスと関連付けることで他のプロセスがリソースをアクセスできないようにしている
- スレッド
  - 実行単位の事。OSから決められた時間を与えられ実行される
  - ひとつのプロセスは一つ以上のスレッドを持っている
  - 一つのプロセス内のスレッドは、リソースのアクセスを共有する
  - CPUはコア数に応じて、同時にひとつあるいは複数のスレッドの命令を行うことができる
  - スレッドの仕事のスケージュールはOSのしごと
- ゴルーチン
  - Goのランタイムによって管理される「軽い」スレッド
  - Goのプログラム開始時に、プログラムを実行するためにいくつかのスレッドを生成し、ひとつのゴルーチンを起動する
  - プログラムに生成されたすべてのゴルーチンはGoのランタイムスケジューラーによって自動的にスレッドに割り当てられる
    - OSがCPUのコアごとにスレッドをスケジュールするのと同じイメージ
    - 利点
      - ゴルーチンの生成はスレッドの生成よりも遥かに早い
        - OSレベルのリソースを生成しているのではないっため
      - ゴルーチンの当初のスタックサイズはスレッドのスタックサイズより小さくなる
        - 必要に応じて大きくできる（メモリを効率的に使用できる）
      - ゴルーチンのスイッチングのほうがスレッドのスイッチングより早い
        - 全体がプロセス内で行われるため、（比較的）遅いシステムコールを避けられる
      - 同一プロセスの処理になるため、スケジューリングを最適化できる
  - Goのプログラムは何千を超えるゴルーチンを同時に動かせる
    - スレッド管理機能がない言語で、何千ものスレッドを起動すると、プログラムの動作は非常に遅くなってしまう
  - 呼び出し時に`go`と関数名の前に置かれているものはゴルーチンになる
  - ビジネスロジックをラップするクロージャとともに起動するのが一般的

## チャネル

- ゴルーチンの情報のやり取りはチャネルを用いる
- チャネルはマップなどと同様の参照型のため、関数に渡す際はポインタを渡しており、ゼロ値はnil
- `ch := make(chan int)`で宣言する
- チャネルの読み込み
  - `a := <-ch`
- チャネルの書き込み
  - `ch <- b`
- チャネルへ書き込まれた値は一度だけ読み込むことができる
- 一つのゴルーチンが同じチャネルに対して、読み書き両方行うのは一般的ではない
- チャネルはデフォルトではバッファリングされない
- バッファリングされないチャネルの書き込みが行われるとき、書き込み側のゴルーチンは、同じチャネルから他のゴルーチンが読み込むまで一時停止する
- バッファ付きの場合は、バッファがたまり切るまで、ブロックされない
- `close(ch)`でチャネルを閉じることができる
  - チャネルを閉じるのは書き込み側の仕事
- チャネルが閉じているかどうかは、カンマokイディオムで確認する

## select

- 複数のチャネルに対しての読み込みあるいは書き込みの操作が可能になる
- 実行順序はその時点で実行可能なものからランダムに選択される

## 並行処理のベストプラクティス

- APIには並行性を含めない
  - 平行性は実装に関する詳細情報のため公開する型、関数、メソッドにチャネルを含めないようにする
    - チャネルを表に出すとチャネル管理の責任をAPIのユーザーに追わせることになる
- ゴルーチンが外側の変数に依存している場合は、意図していない挙動になることがある
  - ゴルーチンの引数に値をいれると回避ができる
- ゴルーチンとして実行される関数を起動する際は確実に終了するようにしなければならない
  - Goのランタイムは使われていないゴルーチンを検知できない
  - 例えば、チャネルの値を取得する際に条件式などで途中で取得をやめ、他の処理を行うなど
- doneチャネルパターンを使用することで、ゴルーチンに対して処理を終了すべきときであるというシグナルを送ることができる
- キャンセレーション関数を用いることでもゴルーチンの終了を促せる
  - キャンセレーション関数：ゴルーチンを終了する関数を戻り値として返してあげる
- バッファ付きのチャネルを使用するタイミング
  - 起動するゴルーチンの数を制限したい
  - バッファに入ったものの処理に制限をかけたい
- selectでcaseがクローズされたものを読み込むと常に成功するがnilになるため、カンマokイディオムを用いて確認する必要がある

## mutex

- スレッド間でのデータ共有を行う場合は他言語ではmutexを用いることが多いが、goではチャネルとselectを用いている
  - データの流れが明快になるから
- goにもmutexは存在し、複数のゴルーチンが共有されたデータを読み込んだり、単純な書き込みは行うがその値を処理はしない場合に有用